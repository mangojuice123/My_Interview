- [题目](#题目)
- [Follow up](#follow-up)
- [测试用例](#测试用例)
- [题解](#题解)
- [复杂度](#复杂度)
- [公司](#公司)

</br></br>

# 题目
- [415. Add Strings](https://leetcode.com/problems/add-strings/)
> Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.

# Follow up
- [36 进制加法](https://leetcode-cn.com/circle/discuss/I8NZUx/)
- [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)

# 测试用例

# 题解
1. 字符串相加（大数相加）。
```
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        # 保证 num1 是较长的串
        if len(num1) < len(num2):
            num1, num2 = num2, num1
        # 从低位向高位相加
        num1, num2 = num1[::-1], num2[::-1]

        m, n = len(num1), len(num2)
        res, carry = "", 0
        for i in range(m):
            if i < n:
                digit = ord(num1[i]) - ord("0") + ord(num2[i]) - ord("0")
            else:
                digit = ord(num1[i]) - ord("0")
            # 整除是 // ！
            # carry = digit // 10
            # digit %= 10
            carry, digit = divmod(digit + carry, 10)
            res = str(digit) + res

        # 把最后的进位补上
        if carry != 0:
            res = str(carry) + res

        return res
```
2. 两数相加（链表版的大数相加）。
```
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        if not l1 or not l2:
            return l1 or l2

        dummy = cur = ListNode()
        carry = 0
        while l1 or l2 or carry:
            digit = 0
            if l1:
                digit += l1.val
                l1 = l1.next
            if l2:
                digit += l2.val
                l2 = l2.next
            carry, digit = divmod(digit + carry, 10)
            cur.next = ListNode(digit)
            cur = cur.next

        return dummy.next
```

# 复杂度
- 时间复杂度：`O(m + n)`
- 空间复杂度：`O(1)`

# 公司
- 2021-8 美团
- 2021-7 虾皮