- [题目](#题目)
- [Follow up](#follow-up)
- [测试用例](#测试用例)
- [题解](#题解)
- [复杂度](#复杂度)
- [公司](#公司)

</br></br>

# 题目
- [47. Permutations II](https://leetcode.com/problems/permutations-ii/)
> Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.

# Follow up
- [90. Subsets II](https://leetcode.com/problems/subsets-ii/)

# 测试用例

# 题解
1. 排列
```
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        # 先排序，后去重
        nums = sorted(nums)
        visited = [False] * n
        res = []
        self.helper(nums, [], visited, res)
        return res

    def helper(self, nums, path, visited, res):
        n = len(nums)
        if len(path) == n:
            res.append(path)
        # 到达尾部直接返回
        else: 
            for i in range(n):
                # 去重
                if i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]:
                    continue
                if not visited[i]:
                    visited[i] = True
                    self.helper(nums, path + [nums[i]], visited, res)
                    visited[i] = False 
```

2. 子集
```
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        ans = []
        nums = sorted(nums)
        self.backtracking(ans, [], nums, 0)
        return ans
        
    def backtracking(self, ans, path, nums, start):
        ans.append(path.copy())
        for i in range(start, len(nums)):
            if i > start and nums[i] == nums[i-1]:
                continue
            path.append(nums[i])
            self.backtracking(ans, path, nums, i+1)
            path.pop()
```

# 复杂度
- 时间复杂度：`O(n * n!)`
- 空间复杂度：`O(n)`

# 公司