- [模版](#模版)
  - [window 记录元素个数](#window-记录元素个数)
  - [window 记录元素下标](#window-记录元素下标)


</br></br>


# 模版
## window 记录元素个数
```
window = defaultdict(int)
# 某个元素不存在可以直接使用 window[element] == 0 进行判断。
start, end, res, n = 0, 0, 0, len(s)
condition = 0, len(p) or ... if needed


# Initialize the dictionary here if needed (Maybe we don't need to do the initialization first).

while end < n:
    if window[s[end]] ### :
        # Modify condition here.
    window[s[end]] -= 1 or window[s[end]] += 1

    # 1. end 滑动窗口的右边界总会向右边移动（end 在 while 循环前或者之后移动均可）。
    end += 1

    while condition:
        ...
        ...
        ...

        window[s[start]] += 1 or window[s[start]] -= 1
        if window[s[start]] ### :
            # Modify condition here.

        # 2. 只有在符合条件的情况下，滑动窗口的左边界才会缩小（即向右移动）。
        start += 1

    # 3. 在 start += 1 前更新 res 或在跳出 while 循环后更新 res。

# Return the corresponding answer.
```

## window 记录元素下标
- [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # start 表示上一个最长无重复子串的起始位置。
        # last 记录每个元素上次出现的下标。
        # 
        # -------------- --- start --- ------------------ --- index
        # last[s[index]] --- ----- --- last[s[index]] + 1 --- -----
        last, start, res, n = {}, 0, 0, len(s) 
        for index in range(n):
            if s[index] in last:
                start = max(start, last[s[index]] + 1)
            
            res = max(res, index - start + 1)
            last[s[index]] = index

        return res 
```