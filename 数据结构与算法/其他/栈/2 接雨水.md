- [题目](#题目)
- [Follow up](#follow-up)
- [测试用例](#测试用例)
- [题解](#题解)
- [复杂度](#复杂度)
- [公司](#公司)

</br></br>

# 题目
- [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)
> Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

# Follow up
- 空间复杂度为 `O(1)`
  - 双指针
- [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)
> You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.



# 测试用例

# 题解
1. 单调栈（空间复杂度 `O(n)`）
```
class Solution:
    def trap(self, height: List[int]) -> int:
        monoStack = []
        res = 0
        n = len(height)

        for i in range(n):
            # 最大值始终在最左边。
            while monoStack and height[monoStack[-1]] <= height[i]:
                #             +---+       
                #             |   |       
                # +---+       |   |       
                # |   |   2   |   |       
                # |   +---+   |   |       
                # |   |   | 1 |   |       
                # +---+---+---+---+       
                #          low  i    
                #
                # 当坐标为 i 时，首先计算横向 1 处的雨水，再计算横向 2 处的雨水
                # 当计算完毕后，将 i 入单调栈                  
                low = monoStack.pop()
                if monoStack:
                    h = min(height[monoStack[-1]], height[i]) - height[low]
                    w = i - 1 - monoStack[-1]
                    res += h * w
            
            monoStack.append(i)

        return res
```
2. 单调队列
```
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        from collections import deque
        n = len(nums)
        queue = deque([])
        res = []

        for i in range(n):
            # 队列的头部始终是最大值。
            #
            # +-+            
            # | |            
            # | |            
            # | |   +-+      
            # | |   | |   +-+
            # | |   | |   | |
            # +-+   +-+   +-+
            #
            while queue and nums[queue[-1]] <= nums[i]:
                queue.pop()
            queue.append(i)

            # 不能依靠单调队列长度判断，只有队列最前端的元素不在当前窗口时，才可以
            # 从队列的左边出队。
            if queue[0] == i - k:
                queue.popleft()

            # 对于每一个窗口，都需要添加一个当前窗口的最大值。
            if i >= k - 1:
                res.append(nums[queue[0]])
        
        return res
```

# 复杂度
- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

# 公司
- 2021-8 字节跳动
- 2021-7 蔚来