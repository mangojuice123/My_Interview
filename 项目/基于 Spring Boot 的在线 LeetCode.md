- [项目描述](#项目描述)
- [亮点](#亮点)
  - [实现编译模块](#实现编译模块)
  - [实现字节码修改器](#实现字节码修改器)
  - [实现运行模块](#实现运行模块)
  - [实现并发处理代码请求模块](#实现并发处理代码请求模块)
- [系统高性能、高可用、可扩展](#系统高性能高可用可扩展)
  - [Premature optimization is the root of all evils.](#premature-optimization-is-the-root-of-all-evils)


</br></br>


# 项目描述
- 基于 Spring Boot 框架实现了一个简单版的在线 LeetCode，利用 JVM 的相关知识，远程运行客户端发来的 Java 代码，并将程序的标准输出内容、运行时异常信息反馈给客户端。
- 项目的挑战：意识到服务端的安全性，实现并发及扩展。


</br></br>


# 亮点
## 实现编译模块
- **使用动态编译技术，可将客户端发来的源代码字符串直接编译为字节数组。**
- 通过 JDK 1.6 后新加的动态编译实现 StringSourceCompiler。使用动态编译，可以直接在内存中将源代码字符串，编译为字节码的字节数组，这样既不会污染环境，又不会引入额外的 IO 操作，一举两得。
- 动态编译的过程：
  1. 得到源代码字符序列；
  2. 编译器对得到对源码进行编译，得到字节码，并且会将得到对字节码封装进一个 `JavaFileObject` 对象；
      - `JavaFileManager` 会 new 一个 `JavaFileObject` 对象返回给编译器，用来存储编译得到的字节码；
  3. 得到 `JavaFileObject` 中用于存放字节码的输出流，并将输出流变成 `byte[]` 数组返回。


</br></br>


## 实现字节码修改器
- **根据 Java 类文件结构修改类的字节码，可将客户端对 System 的调用替换为对 System 的替代类 HackSystem 的调用。**
- 允许客户端程序随便调用 System 的方法存在着安全隐患，并且在多线程的情况下，可能会出现一个客户端输出了另一个客户端信息的错误情况。因此，将程序中的 System 都替换成一个自己写的 HackSystem 类。这样既可以收集到客户端程序的运行结果，又可以将 System 中比较危险的调用都改写成抛出异常，以达到禁止客户端程序调用的目的。
- 直接在字节码中，把要执行的类对 System 的符号引用替换为我们准备的 HackSystem 的符号引用，因此我们需要一个字节码修改器，这个字节码修改器完成如下流程：
  1. 取出常量池中的常量的个数 `constant_pool_count`；
  2. 遍历常量池中 `constant_pool_count` 个常量，检查 tag = 1 的 `CONSTANT_Utf8_info` 常量；
  3. 找到存储的常量值为 `java/lang/System` 的常量（此常量代表了这个类的全限定名），把它替换为 `.../HackSystem`。
  4. 因为只可能有一个值为 `java/lang/System` 的 `CONSTANT_Utf8_info` 常量，所以找到之后可以立即返回修改后的字节码。


</br></br>


## 实现运行模块
- **自定义类加载器 & 热替换，通过反射运行 main 方法。**
- 热加载：在运行过程中实现 `Class` 文件在 `JVM` 中的重新加载，而不用重新启动应用。
- 首先，要注意的是，不可以通过系统可以提供给我们的应用程序类加载器来加载这个类的，因为这个类加载器是独一份的，如果通过这个类加载器加载了我们的字节码，当客户端对源码进行了修改，再次提交运行时，应用程序类加载器会认为这个类已经加载过了，不会再次加载它，这样除非重启服务器，否则我们永远都无法执行客户端提交来的新代码。
- 想要客户端提交来的代码可以不修改类名的随便修改，我们需要支持热加载。我们知道，两个类相等需要满足以下 3 个条件：
  1. 同一个 `.class` 文件；
  2. 被同一个虚拟机加载；
  3. 被同一个类加载器加载；
- 解决方案：每当客户端传来修改后的新类后，new 一个自己写的类加载器进行加载，就可以无数次的加载客户端要运行的类。
  - 写一个 `loadByte` 方法把 `defineClass` (字节流转换为 `java.lang.Class` 对象) 方法开放出来，加载客户端传来的类时显式调用这个方法。
- 只有这个从客户端传来的类需要被多次加载，而这个类调用的其他类库方法，还是要按照原有的双亲委派机制加载的，也就是说，只有我们自己调用 HotswapClassLoader 去加载类时，它直接把字节数组变成 Class 对象，当虚拟机通过反射调用 main 时，它还按照以前的规则使用 loadClass 方法加载类。


</br></br>


## 实现并发处理代码请求模块
- **通过 ThreadLocal 实现线程封闭，为每个请求创建一个输出流，存储标准输出及标准结果。**

![ThreadLocal](https://user-images.githubusercontent.com/57697266/141642679-807cb779-227c-4f97-8f35-f3d3a44e084f.png)

- 为了解决多个客户端带来的并发问题，通过 ThreadLocal 进行线程封闭，将 HackSystem 变成一个线程安全的类。
- 为每个线程创建一个 OutputStream 来保存运行结果，并且将这个 OutputStream 封闭到线程中（这里采用了 `ByteArrayOutputStream` 类）。这样多个线程的标准输出的操作不会互相影响，也就不存在并发问题了。
- HackPrintStream 重写了父类 PrintStream 中所有对流进行操作的方法，将对输出流的操作都变成先获取当前线程的输出流，再执行父类原本的行为。


</br></br>


# 系统高性能、高可用、可扩展
## Premature optimization is the root of all evils.
- 根据系统特点，在上游进行服务器集群，负载均衡，以来提升用户体验。
- 并不是高并发的情况，在用户量没有达到一定的情况下，不需要使用缓存来提升效率，反而会增加系统的复杂度。