- [题目](#题目)
- [Follow up](#follow-up)
- [测试用例](#测试用例)
- [题解](#题解)
- [公司](#公司)

</br></br>

# 题目
- [215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)
> Given an integer array nums and an integer k, return the kth largest element in the array.

# Follow up
- 无序数组中找中位数 `k = len(nums) // 2`
- 证明快速选择算法期望时间复杂度是 `O(n)`
  - 在最佳情况下，每次划分都是绝对均匀的划分，于是每次递归都将数组规模降低为之前的一半，假设直到递归到数组规模为 1 时才结束递归，那么遍历的总元素个数为 `n * (1/2 + 1/4 + 1/8 + ... + 1/2n) = n` => `O(n)`
- 不允许对原数组进行改变，并且空间复杂度为 `O(1)`
  - 使用堆
- 只选出 top 10 至 top 20 之间的元素
  - 实现堆
  - 使用两个大小为 10 的小顶堆，第一个塞满以后弹出来塞入第二个
- 判断一个数是否为第 K 大，数组中有重复元素
- [BFPRT](https://zhuanlan.zhihu.com/p/291206708)


# 测试用例
- 特殊输入测试
- 功能性测试 

# 题解
1. 快速选择算法（快速排序的每次划分需要对两侧进行递归调用，而快速选择只需要对其中一侧进行递归调用）
```
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return self.findK(nums, 0, len(nums) - 1, len(nums) - k)
        
    def findK(self, nums, start, end, target):
        pos = self.partition(nums, start, end)
        if pos == target:
            return nums[pos]
    
        # 递归
        if pos > target:
            return self.findK(nums, start, pos - 1, target)
        else:
            return self.findK(nums, pos + 1, end, target)
    
        # 迭代
        # while target != pos:
        #     if pos > target:
        #         end = pos - 1
        #         pos = self.partition(nums, start, end)
        #     else:
        #         start = pos + 1
        #         pos = self.partition(nums, start, end)
        # return nums[pos]
    
    def partition(self, nums, left, right):
        # 随机选取主元
        import random
        pivot = random.randint(left, right)
        nums[left], nums[pivot] = nums[pivot], nums[left]
        
        pivot = nums[left]
        while left < right:
            while left < right and nums[right] > pivot:
                right -= 1
            nums[left] = nums[right]
            while left < right and nums[left] <= pivot:
                left += 1
            nums[right] = nums[left]
            
        nums[left] = pivot
        return left
```

# 公司
- 2021-8 百度
- 2021-7 字节跳动
- 2021-7 华为
- 2021-6 搜狗 