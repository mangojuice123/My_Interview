- [Java Language](#java-language)
    - [1. 覆盖和重载的区别](#1-覆盖和重载的区别)
    - [2.（堆）内存泄漏和内存溢出的区别、原因、举例](#2堆内存泄漏和内存溢出的区别原因举例)
- [JVM](#jvm)
    - [1. Garbage Collection](#1-garbage-collection)
      - [1. 什么时候进行 GC](#1-什么时候进行-gc)
      - [2. 对什么东西进行 GC](#2-对什么东西进行-gc)
      - [3. GC 具体做了什么事情](#3-gc-具体做了什么事情)
    - [2. 一个线程 OOM 后，其他线程是否能继续运行](#2-一个线程-oom-后其他线程是否能继续运行)
    - [3. Java 对象的分配过程是如何保证线程安全的](#3-java-对象的分配过程是如何保证线程安全的)
- [Java Multithreading](#java-multithreading)
    - [1. 进程与线程的区别](#1-进程与线程的区别)
    - [2. 为什么使用锁来同步和保护资源](#2-为什么使用锁来同步和保护资源)
    - [3. Java 内存模型与线程](#3-java-内存模型与线程)
- [TCP/IP](#tcpip)
    - [1. Web 的攻击技术](#1-web-的攻击技术)
    - [2. HTTP 与 HTTPS 的区别](#2-http-与-https-的区别)
    - [3. HTTPS 的实现](#3-https-的实现)


# Java Language
### 1. 覆盖和重载的区别
1. Overloading
    - 多个方法可以共享一个方法名，但是每个方法各自的参数不同，值得注意的是函数签名并不包括返回值类型，即不能通过只改变返回值类型来重载函数。
    - 比较典型的例子就是整型数字与整型数字相加的方法，浮点数与浮点数相加的方法，二者使用不同的参数，有着不同的返回值，却有着相同的方法名称。
    ```
    int myMethod(int x, int y) { }
    double myMethod(double x, double y) { }
    ```
2. Overriding
    - 在某些特定情况下用一个实现替换另一个实现。覆盖一般是子类重新定义继承下来的方法，以改变或延伸此方法的行为。
    - Java 5 之前覆盖返回的类型必须一致，Java 5 之后覆盖函数的返回类型可以是基类方法返回值的派生类型。
    ```
    public class AnimalNoise {}
    public class Miaw extends AnimalNoise {}

    public class Animal {
        public AnimalNoise makeNoise() {
            return new AnimalNoise();
        }
    }

    public class Cat extends Animal {
        public Miaw makeNoise() {
            return new Miaw();
        }
    }
    ```
3. 多态
    - 一个类的多态性用 `Overloading` 来表现
    - 子类与父类的多态性用 `Overriding` 来表现

### 2.（堆）内存泄漏和内存溢出的区别、原因、举例
1. Memory Leak
    - 导致 `OutOfMemory` 异常的对象是不必要的（应该被垃圾回收但是没被回收的）
    - 原因
        1. 循环过多或死循环，产生了大量的对象
        2. 静态集合类引起内存泄漏，因为静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放
        3. 单例模式，生命周期和 JVM 一致，如果单例对象持有外部对象的引用，那么这个外部对象也不会被回收
        4. 内部类的对象被长期持有，那么内部类对象所属的外部类对象也不会被回收
        5. `Hash` 值发生改变
    ```
    import java.util.*;
    public class Main {
        static class OOMObject {}

        public static void main(String[] args) {
            List<OOMObject> list = new ArrayList<OOMObject>();

            while (true) {
                list.add(new OOMObject());
            }
        }
    ```
2. Memory Overflow
    - 导致 OutOfMemory 异常的对象是必要的。（申请内存时，没有足够的内存可用）
    - GC 时间过久（98%）
    - 原因
        - Java 虚拟机的堆参数 `-Xmx -Xms` 设置过小 ---> `java -Xms1m -Xmx1m xxx.java`
        - 代码中不合理的设计如对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况
3. 内存泄漏的增多，最终会导致内存溢出


# JVM
### 1. Garbage Collection
![JMM](https://i.stack.imgur.com/4ySVX.png)
#### 1. 什么时候进行 GC
1. 大多数情况下，对象在 Young Generation 中的 Eden Space 中进行分配，当 Eden Space 中没有足够空间进行分配时，虚拟机将发起一次 Minor GC，在发生 Minor GC 之前，虚拟机必须先检查 Old Generation 最大连续可用空间是否大于**新生代所有对象总空间**或者**历次晋升平均大小**
    - 大于，Minor GC
    - 小于，Full GC
2. OOM 的触发条件
    - 内存泄漏
    - [GC 与 非GC 耗时超过了 `GCTimeRatio` 的限制](http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html#par_gc.oom)
3. 降低 GC 的调优策略
    - `NewRatio` 调整新生代老年代比例
    - `SurvivorRatio` 调整 Eden Space 和 Survivor Space 比例
    - `MaxTenuringThreshold` 控制进入 Old Generation 前的生存次数 
#### 2. 对什么东西进行 GC
- reference: 如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 reference 是代表某块内存、某个对象的引用
    - `Object obj = new Object()` 只要这样的关系还存在，永远不会被 GC
- 从 GC Root 开始搜索，搜索不到，而且经过第一次标记，清理后，仍然没有复活的对象
#### 3. GC 具体做了什么事情
- Young Generation
    - Mark-Copy
        - Eden Space : From Survivor : To Survivor = 8 : 1 : 1
        - 每次 Young Generation 可用内存空间为 整个 Young Generation 的 90%
    - Handle Promotion : 内存担保
- Old Generation
    - Mark-Compact
        - 让所有存活的对象向内存空间一端移动，然后直接清理掉边界以外的内存
        - 是一种移动式的回收算法
- Concurrency Mark Sweep(CMS) Collector: 
    1. CMS initial mark (Stop The World)
    2. CMS concurrent mark
    3. CMS remark (Stop The World)
    4. CMS concurrent sweep
    - 缺点：
        1. 对处理器资源敏感
        2. 无法处理浮动垃圾，导致 Full GC 的产生
        3. 由于是基于 Mark-Sweep 算法的实现，导致收集结束时产生大量的空间碎片

### 2. [一个线程 OOM 后，其他线程是否能继续运行](https://zhuanlan.zhihu.com/p/151028855)
```
new Thread() {
    @Override
    public void run() {
        int _1MB = 1024 * 1024;
        List<byte[]> list = new ArrayList<>();
        while (true) {
            System.out.println(new Date().toString() + " " + Thread.currentThread().getName());
            byte[]  b = new byte[1 * _1MB];
            list.add(b);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}.start();

new Thread() {
    @Override
    public void run() {
        while (true) {
            // System.out.println(new Date().toString() + " " + Thread.currentThread().getName());
            System.out.println(System.currentTimeMillis() + " " + Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}.start();
```
1. 线程一一直在分配对象，并且这些对象有强引用指着，所以线程一的运行过程中这部分内存一只无法回收，直到 Heap 满
2. 触发 Full GC，尝试回收，发现无法回收，JVM 抛出 OOM
3. 由于线程一没有 catch 这个 error，线程一退出
4. 由于线程一中产生的对象已经没有强引用指着，这部分内存是线程一独占，因此当线程退出后，内存资源被释放
5. 只要有一个非 deamon 线程存活，JVM 就不会退出

### 3. Java 对象的分配过程是如何保证线程安全的
1. Compare And Swap([CAS](https://www.jianshu.com/p/fb6e91b013cc))
    - 当前内存值 `V`， 旧的预期值 `A`，准备设置的新值 `B`
    - 当且仅当预期值 `A == V`，将内存值修改为 `B`，否则什么都不做
2. [Thread Local Allocation Buffer(TLAB)](https://www.cnblogs.com/hollischuang/p/12453988.html)
    - 在线程初始化时，虚拟机会为每个线程分配一块 TLAB 空间，只给当前线程使用，当需要分配内存时，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。
    - 在 `分配` 这个动作上是线程独占的，其他方面则是共享的
    - TLAB 的空间其实并不大，所以大对象还是可能需要在堆内存中直接分配。那么，对象的内存分配步骤就是先尝试 TLAB 分配，空间不足之后，再判断是否应该直接进入老年代，然后再确定是再 Eden 分配还是在老年代分配。


# Java Multithreading
### 1. 进程与线程的区别
1. 进程与线程最大的区别就是**内存是否共享**
    - 每个进程都拥有彼此独立的内存空间
    - 线程之间共享内存（Java 内存模型中包含共享内存和缓存这两种内存。其中，线程之间共享的是共享内存）
        - 由于线程之间共享内存，所以线程之间的通信可以很自然、简单地实现
        - 一个线程向实例中写入内容，其他线程就可以读取该实例的内容
2. 线程的上下文切换比进程快
    - 当执行紧密关联的多项工作时，通常线程比进程更加合适

### 2. 为什么使用锁来同步和保护资源
1. [race condition](https://stackoverflow.com/questions/34510/what-is-a-race-condition)
    - 当有多个线程存在，并且在同一时间访问共享数据时，会造成 race condition
    - 看起来好像这些线程在比赛抢着去访问这些数据一样
    ```
    if (x == 5) // The "Check"
    {
        // If another Thread changed x in between
        // y will not be equal to 10.

        y = x * 2; // The "Act"
    }
    ```
2. 死锁
    - ![死锁](https://user-images.githubusercontent.com/57697266/132002155-d30e4a04-8834-484e-a1cb-14383fe8ec25.png)
    ```
    new EaterThread("Alice", spoon, fork).start();
    new EaterThread("Bobby", fork, spoon).start();
    
    class EaterThread extends Thread {
        private final Tool leftHand;
        private final Tool rightHand;
        public EaterThread(Tool leftHand, Tool rightHand) {
            this.leftHand = leftHand;
            this.rightHand = rightHand;
        }

        @Override
        public void run() {
            while (true) {
                eat();
            }
        }

        public void eat() {
            synchronized(leftHand) {
                // 使用左边的餐具
                synchronized(rightHand) {
                    // 使用右边的餐具
                }
            }
        }
    }
    ```

### 3. Java 内存模型与线程
1. volatile
    - 某个线程对 volatile 字段进行的写操作结果对其他线程立即可见
    - [禁止指令重排序优化（对象的构造过程不是原子性的）](https://www.cnblogs.com/paddix/p/5428507.html)
    - [单例模式的线程安全](https://zhuanlan.zhihu.com/p/52316864)
    ```
    public class Singleton {
        private volatile static Singleton instance; // 注意 volatile 关键字 

        public static Singleton getInstance() {
            if (instance == null) {
                synchronized (Single.class) {
                    if (instance == null) {
                        // 如果没有 volatile 关键字，那么执行对象构造的过程中可能出现指令重排
                        instance = new Singleton(); 
                    }
                }
            }
            return instance;
        }
    }
    ```
2. 原子性、可见性与有序性
    - 原子性：基本数据类型的访问、读写都是具备原子性的
    - 可见性：当一个线程修改了共享变量的值时，其他线程能立即得知这个修改
        - volatile
        - synchronized
        - final
    - [有序性](https://stackoverflow.com/questions/16213443/instruction-reordering-happens-before-relationship-in-java)：如果在本线程内观察，所有的操作都是有序的（Within-Thread As-If-Serial Semantics）；如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序以及工作内存与主存同步延迟）


# TCP/IP
### 1. Web 的攻击技术
1. 主动攻击：直接对服务器上对资源进行攻击，比较有代表性的是 `SQL 注入攻击` 和 `OS 命令注入攻击` 
    - SQL Injection 
        1. SQL Injection Based on `1 = 1` is Always True
        ```
        TxtUserID = getRequestString("UserID");
        txtSQL = "SELECT * FROM user WHERE user_id = " + txtUserId;
        ``` 
        ```
        > UserID: 105 OR 1 = 1
        SELECT * FROM user WHERE user_id = 105 OR 1 = 1;
        ```
        2. SQL Injection Based on `"" = ""` is Always True
        3. SQL Injection Based on Batched SQL Statements
            ```
            > UserID: 105; DROP TABLE suppliers;
            ```
    - Use SQL Parameters for Protection
        ```
        txtUserId = getRequestString("UserId");
        txtSQL = "SELECT * FROM user WHERE user_id = @0";
        db.Execute(txtSQL, txtUserId);
        ```
2. 被动攻击：攻击者不直接对目标 Web 应用发起攻击，而是诱使用户触发已经设置好的陷阱，获取用户的资源和权限，比较有代表性的是跨站脚本攻击（XSS）和跨站点请求伪造

### 2. HTTP 与 HTTPS 的区别
- HTTP + 通信加密 + 证书认证 + 完整性保护 = HTTPS
- HTTP主要有这些不足：
    1. 通信使用明文 -> 窃听
    2. 不验证通信方的身份 -> 伪装
    3. 无法验证报文的完整性 -> 篡改

### 3. HTTPS 的实现