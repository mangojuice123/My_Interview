- [事务](#事务)
  - [Atomicity](#atomicity)
  - [Consistency](#consistency)
  - [Isolation](#isolation)
    - [READ UNCOMMITTED](#read-uncommitted)
    - [READ COMMITTED (RC)](#read-committed-rc)
    - [REPEATABLE READ (RR)](#repeatable-read-rr)
    - [SERIALIZABLE](#serializable)
  - [Durability](#durability)
- [常见问题](#常见问题)
  - [MySQL 死锁示例](#mysql-死锁示例)
  - [什么是 MVCC ？](#什么是-mvcc-)
- [公司](#公司)


</br></br>


# 事务
## Atomicity
- 整个数据库事务是不可分割等工作单位。

## Consistency
- 事务将数据库从一种状态转变为下一种一致的状态（事务前后某个键都是唯一约束）。

## Isolation
- 事务提交前对其他事务都不可见。
### READ UNCOMMITTED
- 脏数据：事务对缓冲池中行记录的修改，并且还没有被提交（commit）。
- 脏读：在不同的事务下，当前事务可以读到另外事务未提交的数据。（总是读取最新的数据）

### READ COMMITTED (RC)
- 不可重复读：当前事务在不同的时间读取同一条数据获取的结果不一致（其他事务一旦提交完成，即可读取到数据）
- MVCC 总是读取被锁定行的最新一份快照数据（ReadView 会改变）

### REPEATABLE READ (RR)
- Phantom Problem：同一事务下，连续执行两次同样的 SQL 语句可能导致不同的结果，**第二次的 SQL 语句可能会返回之前不存在的行**。
- 在 RR 隔离级别下，如何避免幻读？
  - 快照读（针对 SELECT 操作）：对于快照数据，总是读取事务开始时的行数据版本（ReadView 生成后不再改变）。
  - 当前读（针对数据修改操作）：使用 Next-Key Lock (Gap Lock + Record Lock) 实现实际意义上的 SERIALIZABLE 的隔离级别。


### SERIALIZABLE

## Durability
- 事务一旦提交，其结果就是永久性的。


</br></br>


# 常见问题
## MySQL 死锁示例
答：
|A|B|
|:-- |:--|
|begin;| |
|select * from t where a = 1 for update;|begin;|
| |select * from t where a = 2 for update;|
|select * from t where a = 2 for update;| |
| |select * from t where a = 1 for update;|

## 什么是 MVCC ？
答：
- 一个行记录可能有不止一个快照数据，称这种技术为**行**多版本技术。由此带来的并发控制，称之为 MVCC (Multi Version Concurrency Control)，是一个逻辑上的概念，通过每行记录后保存两个隐藏的列（事务 ID，行的回滚指针）来实现的。
- 在 RR 隔离级别下可以消除不可重复读问题，但是不能解决幻读问题（幻读的解决依赖于 Next-Key Lock）。


</br></br>


# 公司
- 2021-5 B站