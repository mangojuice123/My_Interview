- [常见问题](#常见问题)
  - [什么时候进行 GC ？](#什么时候进行-gc-)
  - [对什么东西进行 GC ？](#对什么东西进行-gc-)
  - [GC 具体做了什么事情 ?](#gc-具体做了什么事情-)
  - [Java 对象的分配过程是如何保证线程安全的？](#java-对象的分配过程是如何保证线程安全的)
- [公司](#公司)


</br></br>


# 常见问题
## 什么时候进行 GC ？
答：
1. 大多数情况下，对象在 Young Generation 中的 Eden Space 中进行分配，当 Eden Space 中没有足够空间进行分配时，虚拟机将发起一次 Minor GC，在发生 Minor GC 之前，虚拟机必须先检查 Old Generation 最大连续可用空间是否大于**新生代所有对象总空间**或者**历次晋升平均大小**
    - 大于，Minor GC；
    - 小于，Full GC。
2. OOM 的触发条件：
    - [GC 与非 GC 耗时超过了 `GCTimeRatio` 的限制](http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html#par_gc.oom)。
3. 降低 GC 的调优策略：
    - `NewRatio` 调整新生代老年代比例；
    - `SurvivorRatio` 调整 Eden Space 和 Survivor Space 比例；
    - `MaxTenuringThreshold` 控制进入 Old Generation 前的生存次数。 


## 对什么东西进行 GC ？
- reference: 如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 reference 是代表某块内存、某个对象的引用。
    - `Object obj = new Object()` 只要这样的关系还存在，永远不会被 GC。
- 从 GC Root 开始搜索，搜索不到，而且经过第一次标记，清理后，仍然没有复活的对象。


## GC 具体做了什么事情 ?
- Young Generation
    - Mark-Copy
        - Eden Space : From Survivor : To Survivor = 8 : 1 : 1
        - 每次 Young Generation 可用内存空间为 整个 Young Generation 的 90%
    - Handle Promotion : 内存担保
- Old Generation
    - Mark-Compact
        - 让所有存活的对象向内存空间一端移动，然后直接清理掉边界以外的内存
        - 是一种移动式的回收算法
- Concurrency Mark Sweep (CMS) Collector: 
    1. CMS initial mark (Stop The World)
    2. CMS concurrent mark
    3. CMS remark (Stop The World)
    4. CMS concurrent sweep
    - 缺点：
        1. 对处理器资源敏感
        2. 无法处理浮动垃圾，导致 Full GC 的产生
        3. 由于是基于 Mark-Sweep 算法的实现，导致收集结束时产生大量的空间碎片


## Java 对象的分配过程是如何保证线程安全的？
答：
- [Thread Local Allocation Buffer (TLAB)](https://www.cnblogs.com/hollischuang/p/12453988.html)
    - 在线程初始化时，虚拟机会为每个线程分配一块 TLAB 空间，只给当前线程使用，当需要分配内存时，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率；
    - 在 `分配` 这个动作上是线程独占的，其他方面则是共享的；
    - TLAB 的空间其实并不大，所以大对象还是可能需要在堆内存中直接分配。那么，对象的内存分配步骤就是先尝试 TLAB 分配，空间不足之后，再判断是否应该直接进入老年代，然后再确定是再 Eden 分配还是在老年代分配。

</br></br>


# 公司