- [常见问题](#常见问题)
  - [（堆）内存泄漏和内存溢出的区别、原因、举例](#堆内存泄漏和内存溢出的区别原因举例)
  - [一个线程 OOM 后，其他线程是否能继续运行？](#一个线程-oom-后其他线程是否能继续运行)
- [公司](#公司)


</br></br>


![JMM](https://i.stack.imgur.com/4ySVX.png)


</br></br>


# 常见问题
## （堆）内存泄漏和内存溢出的区别、原因、举例
答：
1. Memory Leak
    - 导致 `OutOfMemory` 异常的对象是不必要的（应该被垃圾回收但是没被回收的）。
    - 原因：
        1. 循环过多或死循环，产生了大量的对象；
        2. 静态集合类引起内存泄漏，因为静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放；
        3. 单例模式，生命周期和 JVM 一致，如果单例对象持有外部对象的引用，那么这个外部对象也不会被回收；
        4. 内部类的对象被长期持有，那么内部类对象所属的外部类对象也不会被回收；
        5. `Hash` 值发生改变。
    ```
    import java.util.*;
    public class Main {
        static class OOMObject {}

        public static void main(String[] args) {
            List<OOMObject> list = new ArrayList<OOMObject>();

            while (true) {
                list.add(new OOMObject());
            }
        }
    ```
2. Memory Overflow
    - 导致 OutOfMemory 异常的对象是必要的（申请内存时，没有足够的内存可用）。
    - 原因：
        - Java 虚拟机的堆参数 `-Xmx -Xms` 设置过小 ---> `java -Xms1m -Xmx1m xxx.java`；
        - 代码中不合理的设计如对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况。
3. 二者的联系：内存泄漏的增多，最终会导致内存溢出。


## 一个线程 OOM 后，其他线程是否能继续运行？
答：
- 假设有两个线程，线程一不停地在分配内存，线程二正常运行。
1. 线程一一直在分配对象，并且这些对象有强引用指着，所以线程一的运行过程中这部分内存一只无法回收，直到 Heap 满；
2. 触发 Full GC，尝试回收，发现无法回收，JVM 抛出 OOM；
3. 由于线程一没有 catch 这个 error，线程一退出；
4. 由于线程一中产生的对象已经没有强引用指着，这部分内存是线程一独占，因此当线程退出后，内存资源被释放；
5. 只要有一个非 deamon 线程存活，JVM 就不会退出。


</br></br>


# 公司
- 2020-6 美团