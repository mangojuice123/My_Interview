- [类加载器（Class Loader）](#类加载器class-loader)
- [常见问题](#常见问题)
  - [为什么需要多个类加载器？](#为什么需要多个类加载器)
  - [Java 双亲委派加载模型是什么？](#java-双亲委派加载模型是什么)
- [公司](#公司)


</br></br>

# 类加载器（Class Loader）
- 通过一个类的**全限定名**来获取描述该类的**二进制字节流**，实现这个动作的**代码**被称为「类加载器」。


</br></br>


# 常见问题
## 为什么需要多个类加载器？
答：
1. 保证同一个 JVM 里可以运行不同的应用程序；
   - 假定存在一个应用服务器，上面部署着许多独立的应用，同时他们拥有许多同名却不同版本的类库。为了保证程序的正常运行，不同的应用都应该拥有自己独立的类加载器来进行类的加载，避免应用体系的混乱。
2. 独立地对不同类库进行运行时增强。
   - 类加载器可以在 load class 时对 class 进行重写和覆盖，在此期间就可以对类进行功能性的增强。比如添加面向切面编程时用到的动态代理，以及 debug 等原理。

## Java 双亲委派加载模型是什么？
![](https://uploadfiles.nowcoder.com/images/20190731/2505886_1564538979490_D5D109BB8EA439F60D4960AF194310AF)

答：
- Java 中一共存在四种类型的类加载器：
  - Bootstrap
  - Extension
  - Application
  - 自定义
- 双亲委派加载模型工作过程：
  - 当前类加载器收到类加载的请求后，先不尝试自己加载类，而是将请求委派给父类加载器；
    - 因此，所有的类加载请求，都会被先委派给 Bootstrap 加载器；
  - 只有当父类加载器加载失败时，当前类加载器才会自己去尝试加载该类。
- 双亲委派模型具体实现：
  1. 检查该类是否已经被加载了；
  2. 将类加载请求委派给父类，如果父类为 null，则使用 Bootstrap 类加载器；
  3. 当上一步加载失败时，调用自己的 `findClass()` 去加载。
- 破坏双亲委派模型：重写 `loadClass()` 方法。

</br></br>


# 公司